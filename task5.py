# Яким Алексей ПИ17-1
#
# Наибольшей возрастающей подпоследовательностью в массиве из n элементов называется самая
# длинная последовательность элементов массива, простирающаяся слева направо и такая, что
# каждый следующий элемент больше предыдущего.


if __name__ == "__main__":
    # временная сложность алгоритма - O(n)
    # алгоритм заключается в переборе всей последовательности елементов и сравнении:
    # 1. на каждом этапе текущее число сравнивается с предыдущем
    #   1.1. если предыдущее число больше, то сравнивается длина предыдущей максимальной
    #        последовательности и если текущая последовательность длиннее, то она становится
    #        новой максимальной последовательностью
    #   1.2. если текущее число меньше, то увеличивается счетчик длины текущей последовательности,
    #        предыдущий элемент заменяется текущем, происходит переход к следующему элементу

    arr = [1, 2, 3, 1, 4, 5, 6, 7, 1, 2, 3, 4]
    maxCount, count = 0, 1
    prev = arr[0]
    analyticLogestArr = []
    analyticArr = [arr[0]]
    for el in arr[1:]:
        if el > prev:
            count += 1
            analyticArr.append(el)
        else:
            if count > maxCount:
                maxCount = count
                analyticLogestArr = analyticArr[:]
            count = 1
            analyticArr = [el]
        prev = el

    print(f"{maxCount}: {str(analyticLogestArr)}")
    # output >>>
    # 5: [1, 4, 5, 6, 7]
